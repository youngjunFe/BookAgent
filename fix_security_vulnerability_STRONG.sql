-- 🚨🚨🚨 최강 보안 수정: 사용자 데이터 완전 격리 🚨🚨🚨
-- 이 스크립트는 Supabase SQL Editor에서 실행하세요
-- ⚠️  위험: 기존 데이터가 삭제될 수 있습니다. 백업 후 실행하세요!

BEGIN;

-- ==================== 1. 기존 위험한 정책들 모두 제거 ====================
DROP POLICY IF EXISTS "Users can view all ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can insert ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can update ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can delete ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can view all achievements" ON achievements;
DROP POLICY IF EXISTS "Users can update achievements" ON achievements;
DROP POLICY IF EXISTS "Users can manage their goals" ON reading_goals;
DROP POLICY IF EXISTS "Users can view own reviews" ON reviews;
DROP POLICY IF EXISTS "Users can insert own reviews" ON reviews;
DROP POLICY IF EXISTS "Users can update own reviews" ON reviews;
DROP POLICY IF EXISTS "Users can delete own reviews" ON reviews;
DROP POLICY IF EXISTS "Users can view own ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can insert own ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can update own ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can delete own ebooks" ON ebooks;
DROP POLICY IF EXISTS "Users can view own reading goals" ON reading_goals;
DROP POLICY IF EXISTS "Users can insert own reading goals" ON reading_goals;
DROP POLICY IF EXISTS "Users can update own reading goals" ON reading_goals;
DROP POLICY IF EXISTS "Users can delete own reading goals" ON reading_goals;
DROP POLICY IF EXISTS "All users can view achievements" ON achievements;

-- ==================== 2. 테이블 컬럼 추가 ====================
-- reviews 테이블에 user_id 컬럼 추가
ALTER TABLE reviews 
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- ebooks 테이블에 user_id 컬럼 추가  
ALTER TABLE ebooks 
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- reading_goals 테이블에 user_id 컬럼 추가 (이미 있을 수 있지만 확실히)
ALTER TABLE reading_goals 
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- ==================== 3. 기존 데이터 정리 (위험!) ====================
-- ⚠️  경고: 이 부분은 기존 데이터를 삭제합니다!
-- 필요한 경우 주석을 해제하세요

-- 방법 1: user_id가 NULL인 모든 데이터 삭제 (추천)
DELETE FROM reviews WHERE user_id IS NULL;
DELETE FROM ebooks WHERE user_id IS NULL;
DELETE FROM reading_goals WHERE user_id IS NULL;

-- 방법 2: 특정 사용자에게 할당하고 싶다면 아래 주석 해제
-- UPDATE reviews SET user_id = '[실제_사용자_UUID]' WHERE user_id IS NULL;
-- UPDATE ebooks SET user_id = '[실제_사용자_UUID]' WHERE user_id IS NULL;
-- UPDATE reading_goals SET user_id = '[실제_사용자_UUID]' WHERE user_id IS NULL;

-- ==================== 4. 최강 RLS 정책 생성 ====================

-- reviews 테이블 - 철저한 사용자 격리
CREATE POLICY "STRICT_reviews_select" ON reviews 
  FOR SELECT USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_reviews_insert" ON reviews 
  FOR INSERT WITH CHECK (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_reviews_update" ON reviews 
  FOR UPDATE USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  ) WITH CHECK (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_reviews_delete" ON reviews 
  FOR DELETE USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

-- ebooks 테이블 - 철저한 사용자 격리
CREATE POLICY "STRICT_ebooks_select" ON ebooks 
  FOR SELECT USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_ebooks_insert" ON ebooks 
  FOR INSERT WITH CHECK (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_ebooks_update" ON ebooks 
  FOR UPDATE USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  ) WITH CHECK (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_ebooks_delete" ON ebooks 
  FOR DELETE USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

-- reading_goals 테이블 - 철저한 사용자 격리
CREATE POLICY "STRICT_reading_goals_select" ON reading_goals 
  FOR SELECT USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_reading_goals_insert" ON reading_goals 
  FOR INSERT WITH CHECK (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_reading_goals_update" ON reading_goals 
  FOR UPDATE USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  ) WITH CHECK (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

CREATE POLICY "STRICT_reading_goals_delete" ON reading_goals 
  FOR DELETE USING (
    auth.uid() IS NOT NULL AND auth.uid() = user_id
  );

-- achievements는 모든 사용자가 볼 수 있지만 수정은 불가
CREATE POLICY "PUBLIC_achievements_select" ON achievements 
  FOR SELECT USING (true);

-- ==================== 5. RLS 강제 활성화 ====================
ALTER TABLE reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE ebooks ENABLE ROW LEVEL SECURITY;
ALTER TABLE reading_goals ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;

-- ==================== 6. NOT NULL 제약조건 추가 (최강 보안) ====================
-- 새로운 데이터는 반드시 user_id가 있어야 함
-- ⚠️  주의: 기존 데이터가 모두 정리된 후에만 실행

-- 기존 NULL 데이터가 모두 정리되었는지 확인
DO $$ 
BEGIN
  IF EXISTS (SELECT 1 FROM reviews WHERE user_id IS NULL) THEN
    RAISE EXCEPTION 'reviews 테이블에 user_id가 NULL인 데이터가 있습니다. 먼저 정리하세요.';
  END IF;
  
  IF EXISTS (SELECT 1 FROM ebooks WHERE user_id IS NULL) THEN
    RAISE EXCEPTION 'ebooks 테이블에 user_id가 NULL인 데이터가 있습니다. 먼저 정리하세요.';
  END IF;
  
  -- 모든 데이터가 정리되었으면 NOT NULL 제약조건 추가
  ALTER TABLE reviews ALTER COLUMN user_id SET NOT NULL;
  ALTER TABLE ebooks ALTER COLUMN user_id SET NOT NULL;
  -- reading_goals는 이미 NOT NULL일 수 있으므로 조건부 실행
  BEGIN
    ALTER TABLE reading_goals ALTER COLUMN user_id SET NOT NULL;
  EXCEPTION WHEN OTHERS THEN
    -- 이미 NOT NULL이면 무시
    NULL;
  END;
  
  RAISE NOTICE '✅ NOT NULL 제약조건이 성공적으로 추가되었습니다.';
END $$;

-- ==================== 7. 인덱스 생성 (성능 최적화) ====================
CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON reviews(user_id);
CREATE INDEX IF NOT EXISTS idx_ebooks_user_id ON ebooks(user_id);
CREATE INDEX IF NOT EXISTS idx_reading_goals_user_id ON reading_goals(user_id);

-- ==================== 8. 권한 검증 함수 ====================
CREATE OR REPLACE FUNCTION check_user_owns_review(review_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM reviews 
    WHERE id = review_id 
      AND user_id = auth.uid()
      AND auth.uid() IS NOT NULL
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION check_user_owns_ebook(ebook_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM ebooks 
    WHERE id = ebook_id 
      AND user_id = auth.uid()
      AND auth.uid() IS NOT NULL
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ==================== 9. 최종 검증 ====================
DO $$
DECLARE
  review_count INTEGER;
  ebook_count INTEGER;
  goal_count INTEGER;
BEGIN
  -- 각 테이블의 데이터 상태 확인
  SELECT COUNT(*) INTO review_count FROM reviews WHERE user_id IS NULL;
  SELECT COUNT(*) INTO ebook_count FROM ebooks WHERE user_id IS NULL;
  SELECT COUNT(*) INTO goal_count FROM reading_goals WHERE user_id IS NULL;
  
  RAISE NOTICE '🔍 보안 검증 결과:';
  RAISE NOTICE '- user_id가 NULL인 reviews: %개', review_count;
  RAISE NOTICE '- user_id가 NULL인 ebooks: %개', ebook_count;
  RAISE NOTICE '- user_id가 NULL인 reading_goals: %개', goal_count;
  
  IF review_count = 0 AND ebook_count = 0 AND goal_count = 0 THEN
    RAISE NOTICE '✅ 모든 데이터가 사용자별로 격리되었습니다!';
  ELSE
    RAISE NOTICE '⚠️  아직 NULL 데이터가 있습니다. 수동으로 정리하세요.';
  END IF;
END $$;

COMMIT;

-- 🎉 완료 메시지
DO $$
BEGIN
  RAISE NOTICE '🚨🚨🚨 최강 보안 설정 완료! 🚨🚨🚨';
  RAISE NOTICE '✅ 사용자별 완전 데이터 격리 적용됨';
  RAISE NOTICE '✅ 비인증 사용자 접근 완전 차단';
  RAISE NOTICE '✅ RLS 정책 최고 수준으로 강화';
  RAISE NOTICE '⚠️  이제 앱을 재시작하고 다른 계정으로 테스트하세요!';
END $$;
